---
id: Overview
title: Overview
---

A typical _Strict_ file is easy to understand. Unlike other languages following the [Coding Style](CodingStyle.md) is enforced!

```ocaml
implement App
has log Log

method Run()
  test()
    log.LastLine() is "4"
  log.Write("Hello World")
  log.Write(double(2))

method double(number Number) returns Number
  test
	  double(1) is 2
  return number * 2
```

```ocaml
implement Sort<generic Element is Compared>
has elements MutableList<Element>

method Sort() returns Element[]
  test with [3, 2, 1]
	  Sort() is [1, 2, 3]
  test with [7, 77, 111, -1, 11]
	  Sort() is [-1, 7, 11, 77, 111]
  for rightIndex from elements.Range()
    for leftIndex from 0 to elements.Range().End - rightIndex
      maybeSwap(leftIndex)

method maybeSwap(index Number)
  test with [1, 2, 3]
	  maybeSwap(1)
    elements is [1, 2, 3]
  test with [3, 1]
    maybeSwap(0)
    elements is [1, 3]
  if elements[index] > elements[index+1]
    elements.Swap(index, index + 1)
```

Lower case means private, constructors are autogenerated factories and methods appear in the way they are called. Every method must start wtih at least one test, which are always running in the backrgound via the IDE.

# Strict Is

## Readable

_Strict_ is both readable by humans and machines. It has a simple syntax and throws away much of the boilerplate
code that has to be written in other languages. The language constructs are easy to understand and code can be
read like a good novel. In the compiler pipeline the full source code and the ast are always available to let tools go back and forth easily and quickly.

## Reusable

The main goal of any strict package is to be as reusable as possible. The main problem with most of the code out there, especially with very low level languages is that the code is NOT reusable. If anything changes, any library is different, the PC achitecture is different, if the sun is shining or there isn't a full moon, the code breaks and it is certainly not reusable in all other domains. Code is usually rigid, fragile, we cannot take code and reuse it, etc. it is always coupling and dependencies! [Uncle Bob explains this well in this video](https://www.youtube.com/watch?v=QHnLmvDxGTY).

How do we archive this? Strict checks ALL public code that exists at all times, if there is a package, type, method or even clever algorithm that already exists, it will refuse to compile the code again and force the code to resue the existing code instead. This means there is NO copy+pasting, you can't just take a library you like and make a 5% change to it, you can't take a type or method and just change a detail that doesn't really change the algorithm. High level policies and algorithms should not be coupled with low level crap (as Uncle Bob says in the above video at 34:20).

## Why another language?

We really did not want to invent another language and are great fans and users of .NET, Java, Python, Go and many more good languages. However none of them can be easily understood or written by a computer itself. The syntax for most languages nowadays are easy to learn. However the ecosystems are growing more and more complex, mastering tricks, libraries and frameworks can take many years. So instead of reinventing the wheel, _Strict_ allows you to use any framework or library you like, no matter if it is coming from the Java world, .NET, Python, Go, Javascript, etc.

The main difference to any other language out there is that it can be actually understood and written by machines (unless of course we are just consuming external libraries). It is also the only language we know of that completely enforces TDD and clean code, other languages have great concepts and frameworks and many people doing it correctly, but in no way is it enforced by the language itself, which leads very often to code that is not reusable, can't be understood and a messy eco system of hard to use or even broken libraries, version conflicts and many other pain points.

## Statically Checked

If .strict code is opened and does not show any errors, it already is compiled and will work on your machine and in production. Strong typing, lots of semantic analysis and
testing (built into the language) ensure that code works as expected when deployed. Not only does the compiler understand whats going on through the tests in each method, it can also modify any written code to a more efficient algorithm in realtime or even figure out what you want to do and generate the code for you based on the test without you having written any execution code yet.

## Concurrent

The time of single core processors is at an end. Programs start to improve performance by leveraging the
machines ability to execute work concurrently. Concurrency, however, comes with a lot of pitfalls. Strict
takes the burdon of synchronization and shared state management of the programmer. It is written in a way that can both utilize hundereds or thousands of local threads and also distribute computation accross multiple PCs in the network or cloud if configured for that usecase. Internally it provides coroutines for easy and fast asynchronous execution.

## Parallel

By default all code is executed in parallel (think async/await/coroutines/tasks in other languages), but the compiler will automatically inline code and execute loops sequentially for performance reasons. However in theory all tests, all methods, all calls, all loops are executed in parallel and have to be designed that way (immutable and threadsafe), it is up to the compiler to optimize code paths (unlike other languages were parallelism is optional and hard to enforce correctly). For details see [Concurrency](/docs/Concurrency)

## Composition instead of just Object Oriented

Everything in _Strict_ is an object. However [static methods](<https://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods>) and [inheritance](<https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)>) have purposefully been ommited. Instead objects are [composed of other objects and features](https://en.wikipedia.org/wiki/Component-based_software_engineering). Core concepts like [encapsulation](<https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)>) are still embraced by the language and normal usage and implementation of interfaces or external classes is no problem.

## Functional

Due to the fact that there are no static methods (or any globals), no inheritance and everything can be executed in parallel an obvious conclusion is that this could be accomplished via [purely functional programming](https://en.wikipedia.org/wiki/Purely_functional_programming). All fields are constant by default, methods usually have no side effects and are pure, but the programmer is still able to create mutable fields and methods that have side effects (e.g. void methods and especially calling external libraries). However, this is not the norm. In any case the compiler will optimize code into a more efficient code path, no matter if it sees mutable fields that can be optimized into non mutable fields, or is just optimizing calls away, precalculating parameters, optimizes tail recursion calls, makes code lock free, etc.

## Usable Everywhere

Strict can run in its own VM, which is what is used for testing, development and the IDE. Often you might want to dock your code to a bigger project or framework written in a JDK or .NET language and utilize many benefits there, or you want to run on a specific platform and use all tools and other languages there. Strict is flexible and can run on any x64 or ARM64 platform, plus you can generate code in C#, Java, C++ or specific platforms like Arduino or just write your own backend to [generate something you need](https://en.wikipedia.org/wiki/Domain-specific_language). Older x86 also will work, but are not in the focus for optimizations, in fact using the c backend, anything that can run c, can be used.

## Easy to learn

Like Python or many newer languages, _Strict_ is very easy to read and learn. It is obvious what source code does when you see it for the first time, especially as every method has tests showing how it works.

However writing _Strict_ code is more painful if you don't know the rules and as the name implies the language doesn't allow unclean or hacky code by default. We heavily recommend using the Strict IDE to get started easily. _Strict_ enforces a consistent and reusable code base accross all projects, not just the commonly used packages.

## Open Source

_Strict_ is open source, free to use and modify, we welcome an open ecosystem. Our usecase is to make machines more intelligent, hopefully both you can benefit from the clean code and the growing ecosystem can be utilized by machines in the future to make a better world for all of us :)
